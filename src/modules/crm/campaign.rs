use diesel::prelude::*;
use chrono::{Utc, NaiveDate};
use crate::core::result::CLIERPResult;

// Type alias for convenience
type Result<T> = CLIERPResult<T>;
use crate::database::{
    DatabaseConnection, Campaign, NewCampaign, CampaignStatus, CampaignType, CampaignWithStats
};
use crate::database::schema::{campaigns, leads, customers};
use crate::utils::validation::validate_required_string;
use crate::utils::pagination::{Paginate, PaginationParams, PaginatedResult};
use crate::utils::filters::FilterOptions;

pub struct CampaignService;

impl CampaignService {
    pub fn create_campaign(
        conn: &mut DatabaseConnection,
        name: &str,
        campaign_type: CampaignType,
        description: Option<&str>,
        start_date: NaiveDate,
        end_date: Option<NaiveDate>,
        budget: Option<i32>,
        target_audience: Option<&str>,
        goals: Option<&str>,
    ) -> Result<Campaign> {
        // Validate input
        validate_required_string(name, "name")?;
        if name.len() < 2 {
            return Err(crate::core::error::CLIERPError::Validation(
                "Name must be at least 2 characters long".to_string()
            ));
        }
        if name.len() > 200 {
            return Err(crate::core::error::CLIERPError::Validation(
                "Name cannot exceed 200 characters".to_string()
            ));
        }

        if let Some(end_date) = end_date {
            if end_date <= start_date {
                return Err(crate::core::error::CLIERPError::Validation(
                    "End date must be after start date".to_string()
                ));
            }
        }

        if let Some(budget) = budget {
            if *budget < 0 {
                return Err(crate::core::error::CLIERPError::Validation(
                    "Budget cannot be negative".to_string()
                ));
            }
        }

        // Generate campaign code
        let campaign_code = Self::generate_campaign_code(conn)?;

        // Create new campaign
        let new_campaign = NewCampaign {
            campaign_code,
            name: name.to_string(),
            campaign_type: campaign_type.to_string(),
            status: CampaignStatus::Draft.to_string(),
            description: description.map(|s| s.to_string()),
            start_date,
            end_date,
            budget,
            actual_cost: Some(0),
            target_audience: target_audience.map(|s| s.to_string()),
            goals: goals.map(|s| s.to_string()),
        };

        diesel::insert_into(campaigns::table)
            .values(&new_campaign)
            .execute(conn)?;

        // Get the inserted campaign by name since SQLite doesn't support RETURNING
        campaigns::table
            .filter(campaigns::dsl::name.eq(&new_campaign.name))
            .order(campaigns::dsl::created_at.desc())
            .first::<Campaign>(conn)
            .map_err(Into::into)
    }

    pub fn get_campaign_by_id(conn: &mut DatabaseConnection, campaign_id: i32) -> Result<Option<Campaign>> {
        campaigns::table
            .find(campaign_id)
            .first::<Campaign>(conn)
            .optional()
            .map_err(Into::into)
    }

    pub fn get_campaign_by_code(conn: &mut DatabaseConnection, campaign_code: &str) -> Result<Option<Campaign>> {
        campaigns::table
            .filter(campaigns::dsl::name.eq(campaign_code))
            .first::<Campaign>(conn)
            .optional()
            .map_err(Into::into)
    }

    pub fn get_campaign_with_stats(conn: &mut DatabaseConnection, campaign_id: i32) -> Result<Option<CampaignWithStats>> {
        let campaign = Self::get_campaign_by_id(conn, campaign_id)?;

        if let Some(campaign) = campaign {
            // Get leads generated by this campaign
            let total_leads = leads::table
                .filter(leads::lead_source.eq(&campaign.campaign_code))
                .count()
                .get_result::<i64>(conn)?;

            // Get qualified leads
            let qualified_leads = leads::table
                .filter(leads::lead_source.eq(&campaign.campaign_code))
                .filter(leads::status.eq("qualified"))
                .count()
                .get_result::<i64>(conn)?;

            // Get conversion rate
            let conversion_rate = if total_leads > 0 {
                (qualified_leads as f64 / total_leads as f64) * 100.0
            } else {
                0.0
            };

            // Calculate cost per lead
            let cost_per_lead = if total_leads > 0 && campaign.actual_cost.unwrap_or(0) > 0 {
                campaign.actual_cost.unwrap_or(0) as f64 / total_leads as f64
            } else {
                0.0
            };

            // Calculate ROI (placeholder - would need revenue tracking)
            let roi = 0.0; // TODO: Implement when revenue tracking is available

            Ok(Some(CampaignWithStats {
                campaign,
                total_leads,
                qualified_leads,
                conversion_rate,
                cost_per_lead,
                roi,
            }))
        } else {
            Ok(None)
        }
    }

    pub fn list_campaigns(
        conn: &mut DatabaseConnection,
        filters: &FilterOptions,
        pagination: &PaginationParams,
    ) -> Result<PaginatedResult<Campaign>> {
        let mut query = campaigns::table.into_boxed();

        // Apply filters
        if let Some(search) = &filters.search {
            query = query.filter(
                campaigns::dsl::name.like(format!("%{}%", search))
                    .or(campaigns::dsl::description.like(format!("%{}%", search)))
            );
        }

        if let Some(status_filter) = &filters.status {
            query = query.filter(campaigns::dsl::status.eq(status_filter));
        }

        if let Some(type_filter) = &filters.filter_type {
            query = query.filter(campaigns::dsl::campaign_type.eq(type_filter));
        }

        if let Some(date_from) = filters.date_from {
            query = query.filter(campaigns::dsl::start_date.ge(date_from));
        }

        if let Some(date_to) = filters.date_to {
            query = query.filter(campaigns::dsl::end_date.le(date_to));
        }

        // Apply sorting
        query = match filters.sort_by.as_deref() {
            Some("name") => {
                if filters.sort_desc {
                    query.order(campaigns::dsl::name.desc())
                } else {
                    query.order(campaigns::dsl::name.asc())
                }
            }
            Some("code") => {
                if filters.sort_desc {
                    query.order(campaigns::dsl::name.desc())
                } else {
                    query.order(campaigns::dsl::name.asc())
                }
            }
            Some("type") => {
                if filters.sort_desc {
                    query.order(campaigns::dsl::campaign_type.desc())
                } else {
                    query.order(campaigns::dsl::campaign_type.asc())
                }
            }
            Some("status") => {
                if filters.sort_desc {
                    query.order(campaigns::dsl::status.desc())
                } else {
                    query.order(campaigns::dsl::status.asc())
                }
            }
            Some("start_date") => {
                if filters.sort_desc {
                    query.order(campaigns::dsl::start_date.desc())
                } else {
                    query.order(campaigns::dsl::start_date.asc())
                }
            }
            Some("created_at") => {
                if filters.sort_desc {
                    query.order(campaigns::dsl::created_at.desc())
                } else {
                    query.order(campaigns::dsl::created_at.asc())
                }
            }
            _ => query.order(campaigns::dsl::created_at.desc()),
        };

        query.paginate_result(pagination, conn)
    }

    pub fn update_campaign(
        conn: &mut DatabaseConnection,
        campaign_id: i32,
        name: Option<&str>,
        description: Option<Option<&str>>,
        start_date: Option<NaiveDate>,
        end_date: Option<Option<NaiveDate>>,
        budget: Option<Option<i32>>,
        actual_cost: Option<Option<i32>>,
        target_audience: Option<Option<&str>>,
        goals: Option<Option<&str>>,
    ) -> Result<Campaign> {
        // Check if campaign exists
        let _campaign = Self::get_campaign_by_id(conn, campaign_id)?
            .ok_or_else(|| crate::core::error::CLIERPError::NotFound(
                format!("Campaign with ID {} not found", campaign_id)
            ))?;

        // Validate input
        if let Some(name) = name {
            validate_required_string(name, "name")?;
            if name.len() < 2 {
                return Err(crate::core::error::CLIERPError::Validation(
                    "Name must be at least 2 characters long".to_string()
                ));
            }
            if name.len() > 200 {
                return Err(crate::core::error::CLIERPError::Validation(
                    "Name cannot exceed 200 characters".to_string()
                ));
            }
        }

        // Build update query
        use crate::database::schema::campaigns::dsl::*;
        let mut update_query = diesel::update(campaigns.find(campaign_id));

        if let Some(name_val) = name {
            update_query = update_query.set(name.eq(name_val));
        }
        if let Some(desc_val) = description {
            update_query = update_query.set(description.eq(desc_val.map(|s| s.to_string())));
        }
        if let Some(start_val) = start_date {
            update_query = update_query.set(start_date.eq(*start_val));
        }
        if let Some(end_val) = end_date {
            update_query = update_query.set(end_date.eq(*end_val));
        }
        if let Some(budget_val) = budget {
            update_query = update_query.set(budget.eq(*budget_val));
        }
        if let Some(cost_val) = actual_cost {
            update_query = update_query.set(actual_cost.eq(*cost_val));
        }
        if let Some(audience_val) = target_audience {
            update_query = update_query.set(target_audience.eq(audience_val.map(|s| s.to_string())));
        }
        if let Some(goals_val) = goals {
            update_query = update_query.set(goals.eq(goals_val.map(|s| s.to_string())));
        }

        // Always update the updated_at timestamp
        update_query = update_query.set(updated_at.eq(Utc::now().naive_utc()));

        update_query.execute(conn)?;

        // Get the updated campaign
        campaigns::table
            .find(campaign_id)
            .first::<Campaign>(conn)
            .map_err(Into::into)
    }

    pub fn update_campaign_status(
        conn: &mut DatabaseConnection,
        campaign_id: i32,
        new_status: CampaignStatus,
    ) -> Result<Campaign> {
        diesel::update(campaigns::table.find(campaign_id))
            .set((
                campaigns::dsl::status.eq(new_status.to_string()),
                campaigns::dsl::updated_at.eq(Utc::now().naive_utc()),
            ))
            .execute(conn)?;

        // Get the updated campaign
        campaigns::table
            .find(campaign_id)
            .first::<Campaign>(conn)
            .map_err(Into::into)
    }

    pub fn delete_campaign(conn: &mut DatabaseConnection, campaign_id: i32) -> Result<bool> {
        // Check if campaign has any leads
        let has_leads = leads::table
            .inner_join(campaigns::table.on(leads::dsl::lead_source.eq(campaigns::dsl::name)))
            .filter(campaigns::dsl::id.eq(campaign_id))
            .first::<crate::database::Lead>(conn)
            .optional()?
            .is_some();

        if has_leads {
            return Err(crate::core::error::CLIERPError::BusinessLogic(
                "Cannot delete campaign with existing leads. Set status to completed instead.".to_string()
            ));
        }

        let deleted_rows = diesel::delete(campaigns::table.find(campaign_id))
            .execute(conn)?;

        Ok(deleted_rows > 0)
    }

    pub fn get_campaigns_by_status(
        conn: &mut DatabaseConnection,
        status: CampaignStatus,
    ) -> Result<Vec<Campaign>> {
        campaigns::table
            .filter(campaigns::dsl::status.eq(status.to_string()))
            .order(campaigns::dsl::created_at.desc())
            .load::<Campaign>(conn)
            .map_err(Into::into)
    }

    pub fn get_active_campaigns(conn: &mut DatabaseConnection) -> Result<Vec<Campaign>> {
        let today = Utc::now().naive_utc().date();

        campaigns::table
            .filter(campaigns::dsl::status.eq(CampaignStatus::Active.to_string()))
            .filter(campaigns::dsl::start_date.le(today))
            .filter(
                campaigns::dsl::end_date.is_null()
                    .or(campaigns::dsl::end_date.ge(today))
            )
            .order(campaigns::dsl::start_date.asc())
            .load::<Campaign>(conn)
            .map_err(Into::into)
    }

    pub fn get_campaign_performance(conn: &mut DatabaseConnection) -> Result<Vec<CampaignPerformance>> {
        let campaigns: Vec<Campaign> = campaigns::table
            .filter(campaigns::dsl::status.ne(CampaignStatus::Draft.to_string()))
            .order(campaigns::dsl::created_at.desc())
            .load(conn)?;

        let mut performance = Vec::new();

        for campaign in campaigns {
            let stats = Self::get_campaign_with_stats(conn, campaign.id)?;
            if let Some(stats) = stats {
                performance.push(CampaignPerformance {
                    campaign_id: campaign.id,
                    campaign_code: campaign.campaign_code,
                    campaign_name: campaign.name,
                    campaign_type: campaign.campaign_type,
                    status: campaign.status,
                    total_leads: stats.total_leads,
                    qualified_leads: stats.qualified_leads,
                    conversion_rate: stats.conversion_rate,
                    budget: campaign.budget.unwrap_or(0),
                    actual_cost: campaign.actual_cost.unwrap_or(0),
                    cost_per_lead: stats.cost_per_lead,
                    roi: stats.roi,
                });
            }
        }

        Ok(performance)
    }

    pub fn get_campaign_statistics(conn: &mut DatabaseConnection) -> Result<CampaignStatistics> {
        // Total campaigns count
        let total_campaigns = campaigns::table
            .count()
            .get_result::<i64>(conn)?;

        // Active campaigns count
        let active_campaigns = campaigns::table
            .filter(campaigns::dsl::status.eq(CampaignStatus::Active.to_string()))
            .count()
            .get_result::<i64>(conn)?;

        // Draft campaigns count
        let draft_campaigns = campaigns::table
            .filter(campaigns::dsl::status.eq(CampaignStatus::Draft.to_string()))
            .count()
            .get_result::<i64>(conn)?;

        // Completed campaigns count
        let completed_campaigns = campaigns::table
            .filter(campaigns::dsl::status.eq(CampaignStatus::Completed.to_string()))
            .count()
            .get_result::<i64>(conn)?;

        // Total budget
        let total_budget: Option<i64> = campaigns::table
            .select(diesel::dsl::sum(campaigns::dsl::budget.nullable()))
            .first(conn)?;

        // Total actual cost
        let total_actual_cost: Option<i64> = campaigns::table
            .select(diesel::dsl::sum(campaigns::dsl::spent.nullable()))
            .first(conn)?;

        Ok(CampaignStatistics {
            total_campaigns,
            active_campaigns,
            draft_campaigns,
            completed_campaigns,
            total_budget: total_budget.unwrap_or(0) as i32,
            total_actual_cost: total_actual_cost.unwrap_or(0) as i32,
        })
    }

    fn generate_campaign_code(conn: &mut DatabaseConnection) -> Result<String> {
        let count = campaigns::table
            .count()
            .get_result::<i64>(conn)?;

        Ok(format!("CAMP{:06}", count + 1))
    }
}

#[derive(Debug, serde::Serialize)]
pub struct CampaignPerformance {
    pub campaign_id: i32,
    pub campaign_code: String,
    pub campaign_name: String,
    pub campaign_type: String,
    pub status: String,
    pub total_leads: i64,
    pub qualified_leads: i64,
    pub conversion_rate: f64,
    pub budget: i32,
    pub actual_cost: i32,
    pub cost_per_lead: f64,
    pub roi: f64,
}

#[derive(Debug, serde::Serialize)]
pub struct CampaignStatistics {
    pub total_campaigns: i64,
    pub active_campaigns: i64,
    pub draft_campaigns: i64,
    pub completed_campaigns: i64,
    pub total_budget: i32,
    pub total_actual_cost: i32,
}