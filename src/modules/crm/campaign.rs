use diesel::prelude::*;
use chrono::{Utc, NaiveDate};
use crate::core::result::CLIERPResult;
use crate::database::{
    DatabaseConnection, Campaign, NewCampaign, CampaignStatus, CampaignType, CampaignWithStats
};
use crate::database::schema::{campaigns, leads, customers};
use crate::utils::validation::validate_required_string;
use crate::utils::pagination::{Paginate, PaginationParams, PaginatedResult};
use crate::utils::filters::FilterOptions;

pub struct CampaignService;

impl CampaignService {
    pub fn create_campaign(
        conn: &mut DatabaseConnection,
        name: &str,
        campaign_type: CampaignType,
        description: Option<&str>,
        start_date: NaiveDate,
        end_date: Option<NaiveDate>,
        budget: Option<i32>,
        target_audience: Option<&str>,
        goals: Option<&str>,
    ) -> Result<Campaign> {
        // Validate input
        let validator = Validator::new();
        validator
            .required("name", name)?
            .min_length("name", name, 2)?
            .max_length("name", name, 200)?;

        if let Some(end_date) = end_date {
            if end_date <= start_date {
                return Err(crate::core::error::CLIERPError::Validation(
                    "End date must be after start date".to_string()
                ));
            }
        }

        if let Some(budget) = budget {
            validator.positive("budget", *budget as f64)?;
        }

        // Generate campaign code
        let campaign_code = Self::generate_campaign_code(conn)?;

        // Create new campaign
        let new_campaign = NewCampaign {
            campaign_code,
            name: name.to_string(),
            campaign_type: campaign_type.to_string(),
            status: CampaignStatus::Draft.to_string(),
            description: description.map(|s| s.to_string()),
            start_date,
            end_date,
            budget,
            actual_cost: Some(0),
            target_audience: target_audience.map(|s| s.to_string()),
            goals: goals.map(|s| s.to_string()),
        };

        diesel::insert_into(campaigns::table)
            .values(&new_campaign)
            .returning(Campaign::as_returning())
            .get_result(conn)
            .map_err(Into::into)
    }

    pub fn get_campaign_by_id(conn: &mut DatabaseConnection, campaign_id: i32) -> Result<Option<Campaign>> {
        campaigns::table
            .find(campaign_id)
            .first::<Campaign>(conn)
            .optional()
            .map_err(Into::into)
    }

    pub fn get_campaign_by_code(conn: &mut DatabaseConnection, campaign_code: &str) -> Result<Option<Campaign>> {
        campaigns::table
            .filter(campaigns::campaign_code.eq(campaign_code))
            .first::<Campaign>(conn)
            .optional()
            .map_err(Into::into)
    }

    pub fn get_campaign_with_stats(conn: &mut DatabaseConnection, campaign_id: i32) -> Result<Option<CampaignWithStats>> {
        let campaign = Self::get_campaign_by_id(conn, campaign_id)?;

        if let Some(campaign) = campaign {
            // Get leads generated by this campaign
            let total_leads = leads::table
                .filter(leads::lead_source.eq(&campaign.campaign_code))
                .count()
                .get_result::<i64>(conn)?;

            // Get qualified leads
            let qualified_leads = leads::table
                .filter(leads::lead_source.eq(&campaign.campaign_code))
                .filter(leads::status.eq("qualified"))
                .count()
                .get_result::<i64>(conn)?;

            // Get conversion rate
            let conversion_rate = if total_leads > 0 {
                (qualified_leads as f64 / total_leads as f64) * 100.0
            } else {
                0.0
            };

            // Calculate cost per lead
            let cost_per_lead = if total_leads > 0 && campaign.actual_cost.unwrap_or(0) > 0 {
                campaign.actual_cost.unwrap_or(0) as f64 / total_leads as f64
            } else {
                0.0
            };

            // Calculate ROI (placeholder - would need revenue tracking)
            let roi = 0.0; // TODO: Implement when revenue tracking is available

            Ok(Some(CampaignWithStats {
                campaign,
                total_leads,
                qualified_leads,
                conversion_rate,
                cost_per_lead,
                roi,
            }))
        } else {
            Ok(None)
        }
    }

    pub fn list_campaigns(
        conn: &mut DatabaseConnection,
        filters: &FilterOptions,
        pagination: &PaginationParams,
    ) -> Result<PaginatedResult<Campaign>> {
        let mut query = campaigns::table.into_boxed();

        // Apply filters
        if let Some(search) = &filters.search {
            query = query.filter(
                campaigns::name.like(format!("%{}%", search))
                    .or(campaigns::campaign_code.like(format!("%{}%", search)))
                    .or(campaigns::description.like(format!("%{}%", search)))
            );
        }

        if let Some(status_filter) = &filters.status {
            query = query.filter(campaigns::status.eq(status_filter));
        }

        if let Some(type_filter) = &filters.filter_type {
            query = query.filter(campaigns::campaign_type.eq(type_filter));
        }

        if let Some(date_from) = filters.date_from {
            query = query.filter(campaigns::start_date.ge(date_from));
        }

        if let Some(date_to) = filters.date_to {
            query = query.filter(campaigns::end_date.le(date_to));
        }

        // Apply sorting
        query = match filters.sort_by.as_deref() {
            Some("name") => {
                if filters.sort_desc {
                    query.order(campaigns::name.desc())
                } else {
                    query.order(campaigns::name.asc())
                }
            }
            Some("code") => {
                if filters.sort_desc {
                    query.order(campaigns::campaign_code.desc())
                } else {
                    query.order(campaigns::campaign_code.asc())
                }
            }
            Some("type") => {
                if filters.sort_desc {
                    query.order(campaigns::campaign_type.desc())
                } else {
                    query.order(campaigns::campaign_type.asc())
                }
            }
            Some("status") => {
                if filters.sort_desc {
                    query.order(campaigns::status.desc())
                } else {
                    query.order(campaigns::status.asc())
                }
            }
            Some("start_date") => {
                if filters.sort_desc {
                    query.order(campaigns::start_date.desc())
                } else {
                    query.order(campaigns::start_date.asc())
                }
            }
            Some("created_at") => {
                if filters.sort_desc {
                    query.order(campaigns::created_at.desc())
                } else {
                    query.order(campaigns::created_at.asc())
                }
            }
            _ => query.order(campaigns::created_at.desc()),
        };

        query.paginate_result(pagination, conn)
    }

    pub fn update_campaign(
        conn: &mut DatabaseConnection,
        campaign_id: i32,
        name: Option<&str>,
        description: Option<Option<&str>>,
        start_date: Option<NaiveDate>,
        end_date: Option<Option<NaiveDate>>,
        budget: Option<Option<i32>>,
        actual_cost: Option<Option<i32>>,
        target_audience: Option<Option<&str>>,
        goals: Option<Option<&str>>,
    ) -> Result<Campaign> {
        // Check if campaign exists
        let _campaign = Self::get_campaign_by_id(conn, campaign_id)?
            .ok_or_else(|| crate::core::error::CLIERPError::NotFound(
                format!("Campaign with ID {} not found", campaign_id)
            ))?;

        // Validate input
        let validator = Validator::new();
        if let Some(name) = name {
            validator
                .required("name", name)?
                .min_length("name", name, 2)?
                .max_length("name", name, 200)?;
        }

        // Build update query
        use crate::database::schema::campaigns::dsl::*;
        let mut update_query = diesel::update(campaigns.find(campaign_id));

        if let Some(name_val) = name {
            update_query = update_query.set(name.eq(name_val));
        }
        if let Some(desc_val) = description {
            update_query = update_query.set(description.eq(desc_val.map(|s| s.to_string())));
        }
        if let Some(start_val) = start_date {
            update_query = update_query.set(start_date.eq(*start_val));
        }
        if let Some(end_val) = end_date {
            update_query = update_query.set(end_date.eq(*end_val));
        }
        if let Some(budget_val) = budget {
            update_query = update_query.set(budget.eq(*budget_val));
        }
        if let Some(cost_val) = actual_cost {
            update_query = update_query.set(actual_cost.eq(*cost_val));
        }
        if let Some(audience_val) = target_audience {
            update_query = update_query.set(target_audience.eq(audience_val.map(|s| s.to_string())));
        }
        if let Some(goals_val) = goals {
            update_query = update_query.set(goals.eq(goals_val.map(|s| s.to_string())));
        }

        // Always update the updated_at timestamp
        update_query = update_query.set(updated_at.eq(Utc::now().naive_utc()));

        update_query
            .returning(Campaign::as_returning())
            .get_result(conn)
            .map_err(Into::into)
    }

    pub fn update_campaign_status(
        conn: &mut DatabaseConnection,
        campaign_id: i32,
        new_status: CampaignStatus,
    ) -> Result<Campaign> {
        diesel::update(campaigns::table.find(campaign_id))
            .set((
                campaigns::status.eq(new_status.to_string()),
                campaigns::updated_at.eq(Utc::now().naive_utc()),
            ))
            .returning(Campaign::as_returning())
            .get_result(conn)
            .map_err(Into::into)
    }

    pub fn delete_campaign(conn: &mut DatabaseConnection, campaign_id: i32) -> Result<bool> {
        // Check if campaign has any leads
        let has_leads = leads::table
            .inner_join(campaigns::table.on(leads::lead_source.eq(campaigns::campaign_code)))
            .filter(campaigns::id.eq(campaign_id))
            .first::<crate::database::Lead>(conn)
            .optional()?
            .is_some();

        if has_leads {
            return Err(crate::core::error::CLIERPError::BusinessLogic(
                "Cannot delete campaign with existing leads. Set status to completed instead.".to_string()
            ));
        }

        let deleted_rows = diesel::delete(campaigns::table.find(campaign_id))
            .execute(conn)?;

        Ok(deleted_rows > 0)
    }

    pub fn get_campaigns_by_status(
        conn: &mut DatabaseConnection,
        status: CampaignStatus,
    ) -> Result<Vec<Campaign>> {
        campaigns::table
            .filter(campaigns::status.eq(status.to_string()))
            .order(campaigns::created_at.desc())
            .load::<Campaign>(conn)
            .map_err(Into::into)
    }

    pub fn get_active_campaigns(conn: &mut DatabaseConnection) -> Result<Vec<Campaign>> {
        let today = Utc::now().naive_utc().date();

        campaigns::table
            .filter(campaigns::status.eq(CampaignStatus::Active.to_string()))
            .filter(campaigns::start_date.le(today))
            .filter(
                campaigns::end_date.is_null()
                    .or(campaigns::end_date.ge(today))
            )
            .order(campaigns::start_date.asc())
            .load::<Campaign>(conn)
            .map_err(Into::into)
    }

    pub fn get_campaign_performance(conn: &mut DatabaseConnection) -> Result<Vec<CampaignPerformance>> {
        let campaigns: Vec<Campaign> = campaigns::table
            .filter(campaigns::status.ne(CampaignStatus::Draft.to_string()))
            .order(campaigns::created_at.desc())
            .load(conn)?;

        let mut performance = Vec::new();

        for campaign in campaigns {
            let stats = Self::get_campaign_with_stats(conn, campaign.id)?;
            if let Some(stats) = stats {
                performance.push(CampaignPerformance {
                    campaign_id: campaign.id,
                    campaign_code: campaign.campaign_code,
                    campaign_name: campaign.name,
                    campaign_type: campaign.campaign_type,
                    status: campaign.status,
                    total_leads: stats.total_leads,
                    qualified_leads: stats.qualified_leads,
                    conversion_rate: stats.conversion_rate,
                    budget: campaign.budget.unwrap_or(0),
                    actual_cost: campaign.actual_cost.unwrap_or(0),
                    cost_per_lead: stats.cost_per_lead,
                    roi: stats.roi,
                });
            }
        }

        Ok(performance)
    }

    pub fn get_campaign_statistics(conn: &mut DatabaseConnection) -> Result<CampaignStatistics> {
        // Total campaigns count
        let total_campaigns = campaigns::table
            .count()
            .get_result::<i64>(conn)?;

        // Active campaigns count
        let active_campaigns = campaigns::table
            .filter(campaigns::status.eq(CampaignStatus::Active.to_string()))
            .count()
            .get_result::<i64>(conn)?;

        // Draft campaigns count
        let draft_campaigns = campaigns::table
            .filter(campaigns::status.eq(CampaignStatus::Draft.to_string()))
            .count()
            .get_result::<i64>(conn)?;

        // Completed campaigns count
        let completed_campaigns = campaigns::table
            .filter(campaigns::status.eq(CampaignStatus::Completed.to_string()))
            .count()
            .get_result::<i64>(conn)?;

        // Total budget
        let total_budget: Option<i64> = campaigns::table
            .select(diesel::dsl::sum(campaigns::budget.nullable()))
            .first(conn)?;

        // Total actual cost
        let total_actual_cost: Option<i64> = campaigns::table
            .select(diesel::dsl::sum(campaigns::actual_cost.nullable()))
            .first(conn)?;

        Ok(CampaignStatistics {
            total_campaigns,
            active_campaigns,
            draft_campaigns,
            completed_campaigns,
            total_budget: total_budget.unwrap_or(0) as i32,
            total_actual_cost: total_actual_cost.unwrap_or(0) as i32,
        })
    }

    fn generate_campaign_code(conn: &mut DatabaseConnection) -> Result<String> {
        let count = campaigns::table
            .count()
            .get_result::<i64>(conn)?;

        Ok(format!("CAMP{:06}", count + 1))
    }
}

#[derive(Debug, serde::Serialize)]
pub struct CampaignPerformance {
    pub campaign_id: i32,
    pub campaign_code: String,
    pub campaign_name: String,
    pub campaign_type: String,
    pub status: String,
    pub total_leads: i64,
    pub qualified_leads: i64,
    pub conversion_rate: f64,
    pub budget: i32,
    pub actual_cost: i32,
    pub cost_per_lead: f64,
    pub roi: f64,
}

#[derive(Debug, serde::Serialize)]
pub struct CampaignStatistics {
    pub total_campaigns: i64,
    pub active_campaigns: i64,
    pub draft_campaigns: i64,
    pub completed_campaigns: i64,
    pub total_budget: i32,
    pub total_actual_cost: i32,
}